import 'dotenv/config';
import TelegramBot from 'node-telegram-bot-api';
import fetch from 'node-fetch';
import { ChartJSNodeCanvas } from 'chartjs-node-canvas';

const TOKEN = process.env.TOKEN || '–¢–í–û–ô_API_TOKEN';
const bot = new TelegramBot(TOKEN, { polling: true });

const userJobs = {};
const userCurrencies = {};

let test = null
let topCoins = [];
let lastTopUpdate = 0;
let allCoins = [];
let lastAllUpdate = 0;

async function getTopCoins() {
  const now = Date.now();
  if (topCoins.length && now - lastTopUpdate < 30 * 60 * 1000) return topCoins;
  try {
    const res = await fetch(
      'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1'
    );
    const data = await res.json();
    topCoins = data.map(c => ({ id: c.id, symbol: c.symbol, name: c.name }));
    lastTopUpdate = now;
    return topCoins;
  } catch (err) {
    console.error('–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ç–æ–ø-50:', err);
    return [];
  }
}

async function getAllCoins() {
  const now = Date.now();
  if (allCoins.length && now - lastAllUpdate < 6 * 60 * 60 * 1000) return allCoins;
  try {
    const res = await fetch('https://api.coingecko.com/api/v3/coins/list');
    const data = await res.json();
    allCoins = data;
    lastAllUpdate = now;
    return allCoins;
  } catch (err) {
    console.error('–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ–≤–Ω–æ–≥–æ —Å–ø–∏—Å–∫—É:', err);
    return [];
  }
}

async function getCryptoPrices(selectedCurrencies = []) {
  if (!selectedCurrencies.length) {
    return '‚ö†Ô∏è –¢–∏ —â–µ –Ω–µ –æ–±—Ä–∞–≤ –∂–æ–¥–Ω–æ—ó –≤–∞–ª—é—Ç–∏. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–π "–í–∏–±—Ä–∞—Ç–∏ –≤–∞–ª—é—Ç–∏".';
  }

  const ids = selectedCurrencies.join(',');
  try {
    const res = await fetch(
      `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd&include_24hr_change=true`
    );
    const data = await res.json();

    let prices = '';
    for (const coin of selectedCurrencies) {
      if (data[coin]?.usd === undefined) continue;
      const change = data[coin].usd_24h_change?.toFixed(2);
      prices += `üí∞ ${coin.toUpperCase()}: ${data[coin].usd}$ (${change}% –∑–∞ 24–≥)\n`;
    }

    if (!prices) return '‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –∫—É—Ä—Å. –°–ø—Ä–æ–±—É–π –ø—ñ–∑–Ω—ñ—à–µ.';
    return prices;
  } catch (err) {
    console.error(err);
    return '‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ –∫—É—Ä—Å—É.';
  }
}

// ========================== –ì—Ä–∞—Ñ—ñ–∫ ==========================
const chartCanvas = new ChartJSNodeCanvas({ width: 800, height: 400 });

async function getChart(coinId, days) {
  try {
    const res = await fetch(
      `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days}`
    );
    const data = await res.json();

    const labels = data.prices.map(p => new Date(p[0]).toLocaleDateString());
    const prices = data.prices.map(p => p[1]);

    const config = {
      type: 'line',
      data: {
        labels,
        datasets: [
          {
            label: `${coinId.toUpperCase()} (USD)`,
            data: prices,
            borderColor: 'blue',
            fill: false,
          },
        ],
      },
      options: {
        responsive: false,
        plugins: { legend: { display: true } },
        scales: {
          x: { ticks: { maxTicksLimit: 10 } },
          y: { beginAtZero: false },
        },
      },
    };

    const image = await chartCanvas.renderToBuffer(config);
    return image;
  } catch (err) {
    console.error('–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –≥—Ä–∞—Ñ—ñ–∫–∞:', err);
    return null;
  }
}

// ========================== UI ==========================
function getCoinsPage(coins, page = 0, perPage = 10, selected = []) {
  const start = page * perPage;
  const end = start + perPage;
  const pageCoins = coins.slice(start, end);

  const keyboard = pageCoins.map(c => {
    const isSelected = selected.includes(c.id);
    const label = (isSelected ? '‚úÖ ' : '') + `${c.symbol.toUpperCase()} (${c.name})`;
    return [{ text: label, callback_data: `coin_${c.id}` }];
  });

  const navButtons = [];
  if (page > 0) navButtons.push({ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: `page_${page - 1}` });
  if (end < coins.length) navButtons.push({ text: '‚û°Ô∏è –í–ø–µ—Ä–µ–¥', callback_data: `page_${page + 1}` });

  if (navButtons.length) keyboard.push(navButtons);
  keyboard.push([{ text: 'üîé –ü–æ—à—É–∫', callback_data: 'search' }]);

  return keyboard;
}

async function sendNow(chatId) {
  const selectedCurrencies = userCurrencies[chatId] || [];
  const prices = await getCryptoPrices(selectedCurrencies);
  bot.sendMessage(chatId, prices);
  console.log(`–í—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫—É—Ä—Å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É ${chatId}`);
}

// ========================== BOT ==========================
bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;
  bot.sendMessage(chatId, '–ü—Ä–∏–≤—ñ—Ç! –û–±–µ—Ä–∏ –¥—ñ—é:', {
    reply_markup: {
      keyboard: [
        ['–û—Ç—Ä–∏–º–∞—Ç–∏ –∫—É—Ä—Å –∑–∞—Ä–∞–∑', '–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —ñ–Ω—Ç–µ—Ä–≤–∞–ª'],
        ['–í–∏–±—Ä–∞—Ç–∏ –≤–∞–ª—é—Ç–∏', 'üìä –ì—Ä–∞—Ñ—ñ–∫']
      ],
      resize_keyboard: true
    }
  });
});

bot.on('message', async (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text.trim();

  if (text === '–û—Ç—Ä–∏–º–∞—Ç–∏ –∫—É—Ä—Å –∑–∞—Ä–∞–∑') {
    await sendNow(chatId);

  } else if (text === '–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —ñ–Ω—Ç–µ—Ä–≤–∞–ª') {
    bot.sendMessage(chatId, '–í–≤–µ–¥–∏ —ñ–Ω—Ç–µ—Ä–≤–∞–ª —É —Ñ–æ—Ä–º–∞—Ç—ñ –ì–ì:–•–•:–°–°, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥ 02:30:00');

  } else if (/^\d{1,2}:\d{2}:\d{2}$/.test(text)) {
    const [h, m, s] = text.split(':').map(Number);
    if (h >= 24 || m >= 60 || s >= 60) {
      bot.sendMessage(chatId, '–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–π —á–∞—Å. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π —Ñ–æ—Ä–º–∞—Ç –ì–ì:–•–•:–°–°');
      return;
    }
    if (userJobs[chatId]) clearInterval(userJobs[chatId]);
    const intervalMs = ((h * 3600 + m * 60 + s) * 1000);
    userJobs[chatId] = setInterval(() => sendNow(chatId), intervalMs);
    bot.sendMessage(chatId, `–†–æ–∑—Å–∏–ª–∫–∞ –±—É–¥–µ –Ω–∞–¥—Å–∏–ª–∞—Ç–∏—Å—è –∫–æ–∂–Ω—ñ ${text} (–ì–ì:–•–•:–°–°)`);

  } else if (text === '–í–∏–±—Ä–∞—Ç–∏ –≤–∞–ª—é—Ç–∏') {
    const coins = await getTopCoins();
    const selected = userCurrencies[chatId] || [];
    const keyboard = getCoinsPage(coins, 0, 10, selected);

    bot.sendMessage(chatId, '–¢–û–ü-50 –≤–∞–ª—é—Ç –∑–∞ –∫–∞–ø—ñ—Ç–∞–ª—ñ–∑–∞—Ü—ñ—î—é:', {
      reply_markup: { inline_keyboard: keyboard }
    });

  } else if (text === 'üìä –ì—Ä–∞—Ñ—ñ–∫') {
    const selected = userCurrencies[chatId] || [];
    if (!selected.length) {
      bot.sendMessage(chatId, '‚ö†Ô∏è –°–ø–æ—á–∞—Ç–∫—É –≤–∏–±–µ—Ä–∏ —Ö–æ—á–∞ –± –æ–¥–Ω—É –≤–∞–ª—é—Ç—É.');
      return;
    }

    // –ö–ª–∞–≤—ñ–∞—Ç—É—Ä–∞ –∑ –≤–∏–±—Ä–∞–Ω–∏–º–∏ –≤–∞–ª—é—Ç–∞–º–∏
    const keyboard = selected.map(coinId => ([
      { text: coinId.toUpperCase(), callback_data: `chooseChart_${coinId}` }
    ]));

    bot.sendMessage(chatId, '–û–±–µ—Ä—ñ—Ç—å –≤–∞–ª—é—Ç—É –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫–∞:', {
      reply_markup: { inline_keyboard: keyboard }
    });
  }
});

bot.on('callback_query', async (query) => {
  const chatId = query.message.chat.id;
  const data = query.data;

  if (data.startsWith('page_')) {
    const page = parseInt(data.split('_')[1], 10);
    const coins = await getTopCoins();
    const selected = userCurrencies[chatId] || [];
    const keyboard = getCoinsPage(coins, page, 10, selected);

    bot.editMessageReplyMarkup(
      { inline_keyboard: keyboard },
      { chat_id: chatId, message_id: query.message.message_id }
    );
    return;
  }

  if (data.startsWith('coin_')) {
    const coinId = data.split('_')[1];
    if (!userCurrencies[chatId]) userCurrencies[chatId] = [];
    const arr = userCurrencies[chatId];

    if (!arr.includes(coinId)) arr.push(coinId);
    else arr.splice(arr.indexOf(coinId), 1);

    const coins = await getTopCoins();
    const selected = userCurrencies[chatId];
    const keyboard = getCoinsPage(coins, 0, 10, selected);

    bot.editMessageReplyMarkup(
      { inline_keyboard: keyboard },
      { chat_id: chatId, message_id: query.message.message_id }
    );

    bot.answerCallbackQuery(query.id, {
      text: `–í–∏–±—Ä–∞–Ω—ñ: ${arr.map(c => c.toUpperCase()).join(', ') || '–Ω—ñ—á–æ–≥–æ'}`
    });
    return;
  }

  if (data === 'search') {
    bot.sendMessage(chatId, '–í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –∞–±–æ —Å–∏–º–≤–æ–ª –º–æ–Ω–µ—Ç–∏:');
    bot.once('message', async (msg) => {
      const text = msg.text.toLowerCase();
      const coins = await getAllCoins();
      const filtered = coins.filter(c =>
        c.symbol.toLowerCase().includes(text) || c.name.toLowerCase().includes(text)
      ).slice(0, 20);

      if (!filtered.length) {
        bot.sendMessage(chatId, '–ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ üòî');
        return;
      }

      const selected = userCurrencies[chatId] || [];
      const keyboard = getCoinsPage(filtered, 0, 10, selected);
      bot.sendMessage(chatId, `–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–æ—à—É–∫—É –¥–ª—è "${text}":`, {
        reply_markup: { inline_keyboard: keyboard }
      });
    });
    return;
  }

  if (data.startsWith('chooseChart_')) {
    const coinId = data.split('_')[1];

    bot.sendMessage(chatId, `–û–±–µ—Ä—ñ—Ç—å –ø–µ—Ä—ñ–æ–¥ –¥–ª—è ${coinId.toUpperCase()}:`, {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '7 –¥–Ω—ñ–≤', callback_data: `chart_${coinId}_7` },
            { text: '30 –¥–Ω—ñ–≤', callback_data: `chart_${coinId}_30` },
            { text: '1 —Ä—ñ–∫', callback_data: `chart_${coinId}_365` }
          ]
        ]
      }
    });
    return;
  }

  if (data.startsWith('chart_')) {
    const [_, coinId, days] = data.split('_');
    bot.answerCallbackQuery(query.id, { text: `–ë—É–¥—É—é –≥—Ä–∞—Ñ—ñ–∫ –¥–ª—è ${coinId}...` });

    const image = await getChart(coinId, days);
    if (image) {
      bot.sendPhoto(chatId, image, { caption: `üìä ${coinId.toUpperCase()} –∑–∞ ${days} –¥–Ω—ñ–≤` });
    } else {
      bot.sendMessage(chatId, '‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ–±—É–¥—É–≤–∞—Ç–∏ –≥—Ä–∞—Ñ—ñ–∫.');
    }
    return;
  }
});
